"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _neo4jDriverCore = require("neo4j-driver-core");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

/**
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable-next-line no-unused-vars */
var States = {
  READY: 0,
  STREAMING: 1,
  COMPLETED: 2
};
/**
 * The reactive result interface.
 */

var RxResult = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Observable<Result>} result - An observable of single Result instance to relay requests.
   * @param {number} state - The streaming state
   */
  function RxResult(result, state) {
    (0, _classCallCheck2["default"])(this, RxResult);
    var replayedResult = result.pipe((0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._result = replayedResult;
    this._keys = replayedResult.pipe((0, _operators.mergeMap)(function (r) {
      return (0, _rxjs.from)(r.keys());
    }), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._records = undefined;
    this._controls = new StreamControl();
    this._summary = new _rxjs.ReplaySubject();
    this._state = state || States.READY;
  }
  /**
   * Returns an observable that exposes a single item containing field names
   * returned by the executing query.
   *
   * Errors raised by actual query execution can surface on the returned
   * observable stream.
   *
   * @public
   * @returns {Observable<string[]>} - An observable stream (with exactly one element) of field names.
   */


  (0, _createClass2["default"])(RxResult, [{
    key: "keys",
    value: function keys() {
      return this._keys;
    }
    /**
     * Returns an observable that exposes each record returned by the executing query.
     *
     * Errors raised during the streaming phase can surface on the returned observable stream.
     *
     * @public
     * @returns {Observable<Record>} - An observable stream of records.
     */

  }, {
    key: "records",
    value: function records() {
      var _this = this;

      var result = this._result.pipe((0, _operators.mergeMap)(function (result) {
        return new _rxjs.Observable(function (recordsObserver) {
          return _this._startStreaming({
            result: result,
            recordsObserver: recordsObserver
          });
        });
      }));

      result.push = function () {
        return _this._push();
      };

      return result;
    }
    /**
     * Returns an observable that exposes a single item of {@link ResultSummary} that is generated by
     * the server after the streaming of the executing query is completed.
     *
     * *Subscribing to this stream before subscribing to records() stream causes the results to be discarded on the server.*
     *
     * @public
     * @returns {Observable<ResultSummary>} - An observable stream (with exactly one element) of result summary.
     */

  }, {
    key: "consume",
    value: function consume() {
      var _this2 = this;

      return this._result.pipe((0, _operators.mergeMap)(function (result) {
        return new _rxjs.Observable(function (summaryObserver) {
          return _this2._startStreaming({
            result: result,
            summaryObserver: summaryObserver
          });
        });
      }));
    }
    /**
     * Pauses the automatic streaming of records.
     *
     * This method provides a way of controll the flow of records
     *
     * @experimental
     */

  }, {
    key: "pause",
    value: function pause() {
      this._controls.pause();
    }
    /**
     * Resumes the automatic streaming of records.
     *
     * This method won't need to be called in normal stream operation. It only applies to the case when the stream is paused.
     *
     * This method is method won't start the consuming records if the ${@link records()} stream didn't get subscribed.
     * @experimental
     * @returns {Promise<void>} - A promise that resolves when the stream is resumed.
     */

  }, {
    key: "resume",
    value: function resume() {
      return this._controls.resume();
    }
    /**
     * Pushes the next record to the stream.
     *
     * This method automatic pause the auto-streaming of records and then push next record to the stream.
     *
     * For returning the automatic streaming of records, use {@link resume} method.
     *
     * @experimental
     * @returns {Promise<void>} - A promise that resolves when the push is completed.
     */

  }, {
    key: "push",
    value: function push() {
      return this._controls.push();
    }
  }, {
    key: "_startStreaming",
    value: function _startStreaming() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          result = _ref.result,
          _ref$recordsObserver = _ref.recordsObserver,
          recordsObserver = _ref$recordsObserver === void 0 ? null : _ref$recordsObserver,
          _ref$summaryObserver = _ref.summaryObserver,
          summaryObserver = _ref$summaryObserver === void 0 ? null : _ref$summaryObserver;

      var subscriptions = [];

      if (summaryObserver) {
        subscriptions.push(this._summary.subscribe(summaryObserver));
      }

      if (this._state < States.STREAMING) {
        this._state = States.STREAMING;

        this._setupRecordsStream(result);

        if (recordsObserver) {
          subscriptions.push(this._records.subscribe(recordsObserver));
        } else {
          result._cancel();
        }

        subscriptions.push({
          unsubscribe: function unsubscribe() {
            if (result._cancel) {
              result._cancel();
            }
          }
        });
      } else if (recordsObserver) {
        recordsObserver.error((0, _neo4jDriverCore.newError)('Streaming has already started/consumed with a previous records or summary subscription.'));
      }

      return function () {
        subscriptions.forEach(function (s) {
          return s.unsubscribe();
        });
      };
    }
    /**
     * Create a {@link Observable} for the current {@link RxResult}
     *
     *
     * @package
     * @experimental
     * @since 5.0
     * @return {Observable<RxResult>}
     */

  }, {
    key: "_toObservable",
    value: function _toObservable() {
      var _this3 = this;

      function wrap(result) {
        return new _rxjs.Observable(function (observer) {
          observer.next(result);
          observer.complete();
        });
      }

      return new _rxjs.Observable(function (observer) {
        _this3._result.subscribe({
          complete: function complete() {
            return observer.complete();
          },
          next: function next(result) {
            return observer.next(new RxResult(wrap(result)), _this3._state);
          },
          error: function error(e) {
            return observer.error(e);
          }
        });
      });
    }
  }, {
    key: "_setupRecordsStream",
    value: function _setupRecordsStream(result) {
      var _this4 = this;

      if (this._records) {
        return this._records;
      }

      this._records = createFullyControlledSubject(result[Symbol.asyncIterator](), {
        complete: function () {
          var _complete = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this4._state = States.COMPLETED;
                    _context.t0 = _this4._summary;
                    _context.next = 4;
                    return result.summary();

                  case 4:
                    _context.t1 = _context.sent;

                    _context.t0.next.call(_context.t0, _context.t1);

                    _this4._summary.complete();

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function complete() {
            return _complete.apply(this, arguments);
          }

          return complete;
        }(),
        error: function error(_error) {
          _this4._state = States.COMPLETED;

          _this4._summary.error(_error);
        }
      }, this._controls);
      return this._records;
    }
  }]);
  return RxResult;
}();

exports["default"] = RxResult;

function createFullyControlledSubject(iterator, completeObserver) {
  var streamControl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new StreamControl();
  var subject = new _rxjs.Subject();

  var pushNextValue = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(result) {
      var _yield$result, done, value;

      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              streamControl.pushing = true;
              _context3.next = 4;
              return result;

            case 4:
              _yield$result = _context3.sent;
              done = _yield$result.done;
              value = _yield$result.value;

              if (done) {
                subject.complete();
                completeObserver.complete();
              } else {
                subject.next(value);

                if (!streamControl.paused) {
                  setImmediate( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return pushNextValue(iterator.next());

                          case 2:
                            return _context2.abrupt("return", _context2.sent);

                          case 3:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  })));
                }
              }

              _context3.next = 14;
              break;

            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](0);
              subject.error(_context3.t0);
              completeObserver.error(_context3.t0);

            case 14:
              _context3.prev = 14;
              streamControl.pushing = false;
              return _context3.finish(14);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[0, 10, 14, 17]]);
    }));

    return function pushNextValue(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  function push(_x2) {
    return _push.apply(this, arguments);
  }

  function _push() {
    _push = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(value) {
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return pushNextValue(iterator.next(value));

            case 2:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _push.apply(this, arguments);
  }

  streamControl.pusher = push;
  push();
  return subject;
}

var StreamControl = /*#__PURE__*/function () {
  function StreamControl() {
    var push = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    (0, _classCallCheck2["default"])(this, StreamControl);
    this._paused = false;
    this._pushing = false;
    this._push = push;
  }

  (0, _createClass2["default"])(StreamControl, [{
    key: "pause",
    value: function pause() {
      this._paused = true;
    }
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
  }, {
    key: "pushing",
    get: function get() {
      return this._pushing;
    },
    set: function set(pushing) {
      this._pushing = pushing;
    }
  }, {
    key: "resume",
    value: function () {
      var _resume = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        var wasPaused;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                wasPaused = this._paused;
                this._paused = false;

                if (!(wasPaused && !this._pushing)) {
                  _context6.next = 5;
                  break;
                }

                _context6.next = 5;
                return this._push();

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function resume() {
        return _resume.apply(this, arguments);
      }

      return resume;
    }()
  }, {
    key: "push",
    value: function () {
      var _push2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this.pause();
                _context7.next = 3;
                return this._push();

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function push() {
        return _push2.apply(this, arguments);
      }

      return push;
    }()
  }, {
    key: "pusher",
    get: function get() {
      return this._push;
    },
    set: function set(push) {
      this._push = push;
    }
  }]);
  return StreamControl;
}();